# Лабораторная работа №4. Вариант 4 (Ripes, RV32I)
#
# Задание:
#   Дан массив A из 500 целых 32-битных чисел.
#   Для каждого элемента A[i] нужно найти первый слева (старший)
#   нулевой бит. Нумерация битов: 31...0.
#   Если нулевых битов нет — записать в B[i] значение -1.
#   Также подсчитать количество элементов без нулевых битов и
#   записать в переменную nozero_count.




.data

N:              .word   500          # размер массива (по условию 500)

# Массив A[500] — здесь должны лежать исходные числа
# первые несколько элементов задать .word, остальное .zero.
A:
    # Первые 10 элементов — разные, чтобы было что показать
    .word 0xFFFFFFFF   # A[0]  - все 1 → нет нулевых битов → B[0] = -1
    .word 0x7FFFFFFF   # A[1]  - 0 111... → первый слева 0 в бите 31
    .word 0x80000000   # A[2]  - 1 000... → первый слева 0 в бите 30
    .word 0x00000000   # A[3]  - все 0 → первый слева 0 в бите 31
    .word 0xF0FFFFFF   # A[4]  - первые 4 бита 1111, потом 0000 → первый 0 в бите 27
    .word 0x0FFFFFFF   # A[5]  - старший байт = 0 → первый 0 в бите 31
    .word 0xAAAAAAAA   # A[6]  - 1010... → первый 0 в бите 30
    .word 0x55555555   # A[7]  - 0101... → первый 0 в бите 31
    .word 0x00000001   # A[8]  - только младший бит 1 → первый 0 в бите 31
    .word 0xFFFFFFFF   # A[9]  - ещё одно число без нулевых битов

    # Остальные 490 элементов — нули 
    .zero 1960         # 490 слов * 4 байта = 1960

B:
    .zero  2000         # 500 * 4


# Счётчик элементов, у которых НЕТ нулевых битов (все 32 бита = 1)
nozero_count:
    .word   0

# Счётчик элементов, у которых есть хотя бы один нулевой бит
haszero_count:
    .word   0

# Строка для вывода результата
msg_nozero:
    .asciz  "Number of elements without zero bits: "
newline:
    .asciz  "\n"


# КОД

.text
.globl _start

_start:
    # s0 — указатель на A[i]
    la      s0, A

    # s1 — указатель на B[i]
    la      s1, B

    # s2 — N (количество элементов)
    la      t0, N
    lw      s2, 0(t0)

    # s3 — i (индекс)
    li      s3, 0

    # s4 — nozero_count
    li      s4, 0

    # s5 — haszero_count
    li      s5, 0


# ЦИКЛ ПО МАССИВУ A

outer_loop:
    bge     s3, s2, done        # если i >= N → конец

    lw      t0, 0(s0)           # t0 = A[i]

    # t1 — маска, начинаем с бита 31 (0x80000000)
    li      t1, 0x80000000

    # t2 — номер проверяемого бита (31..0)
    li      t2, 31


# ПОИСК ПЕРВОГО СЛЕВА НУЛЕВОГО БИТА В t0

bit_search_loop:
    beq     t1, x0, no_zero_bits    # маска обнулилась → нулей нет

    and     t3, t0, t1              # t3 = t0 & t1
    beq     t3, x0, found_zero_bit  # если результат 0 → этот бит = 0

    srli    t1, t1, 1               # сдвигаем маску вправо (следующий бит)
    addi    t2, t2, -1              # номер бита--
    j       bit_search_loop


# НАЙДЁН ПЕРВЫЙ СЛЕВА НУЛЕВОЙ БИТ

found_zero_bit:
    sw      t2, 0(s1)               # B[i] = номер найденного бита
    addi    s5, s5, 1               # haszero_count++
    j       next_element


# НЕТ НИ ОДНОГО НУЛЕВОГО БИТА (число = 0xFFFFFFFF)

no_zero_bits:
    li      t4, -1
    sw      t4, 0(s1)               # B[i] = -1
    addi    s4, s4, 1               # nozero_count++


# ПЕРЕХОД К СЛЕДУЮЩЕМУ ЭЛЕМЕНТУ

next_element:
    addi    s0, s0, 4               # A++
    addi    s1, s1, 4               # B++
    addi    s3, s3, 1               # i++
    j       outer_loop


# ЗАВЕРШЕНИЕ: СОХРАНЯЕМ СЧЁТЧИКИ И ВЫВОДИМ РЕЗУЛЬТАТ

done:
    # Сохраняем счётчики в память (для проверки через Memory)
    la      t0, nozero_count
    sw      s4, 0(t0)

    la      t0, haszero_count
    sw      s5, 0(t0)


    # ВЫВОД ЧЕРЕЗ ECALL

    #   a7 = 4 → print string,  a0 = адрес строки
    #   a7 = 1 → print integer, a0 = число
    #   a7 = 10 → exit


    # Печатаем текст
    la      a0, msg_nozero
    li      a7, 4              # print string
    ecall

    # Печатаем значение nozero_count
    mv      a0, s4
    li      a7, 1              # print integer
    ecall

    # Перенос строки
    la      a0, newline
    li      a7, 4
    ecall

    # Корректный выход
    li      a7, 10             # exit
    ecall

#висим в цикле
end_loop:
    j       end_loop
